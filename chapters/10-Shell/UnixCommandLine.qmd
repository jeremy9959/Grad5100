---
title: The UNIX command line
author: Jeremy Teitelbaum
subtitle: Fundamentals of Data Science
format: html
engine: knitr
execute:
    eval: false
code-block-background: true
---

## Why learn the command line?

1. Access to remote servers is generally purely CLI
2. Process automation often relies on CLI
3. CLI is a quick and efficient way to work with files and directories

## UNIX

*UNIX* is a generic term for a family of operating systems dating back to the
1960's.  Many systems today are in the UNIX family.  The most notable examples are

1. Linux (actually a whole family of Linux OS's) -- derived from an open source system created
by Linus Torvalds
2. MacOS 

In addition, Microsoft now supports a system called WSL (Windows subsystem for Linux) that
allows you to with with Linux on a windows machine. 

## The GNU project

The GNU project is a collection of open source tools written (primarily) for the UNIX ecosystem.
The GNU project includes shells (`bash`), compilers (`gcc`), text editors (`emacs`), and many
other resources.  Most Linux systems are closely integrated with GNU tools.

## The UNIX shell


The *shell* is a program that provides access to a range of tools for working with files
and directoriees, and which can launch other programs that can do pretty much anything.

One can write programs for the shell to execute (these are called *shell scripts*) or one
can use the shell interactively.

There are many shells available but the three you are most likely to encounter are:

- the bourne shell (`sh`).  This is the simplest shell program and mostly occurs in shell scripts.
It is the "lowest common denominator" of UNIX shells.
- `bash` is the standard shell that is associated with the GNU toolkit
- `zsh` has become a popular shell because of its flexibility and its many customization options.

On Windows, the [gitbash package](https://gitforwindows.org) provides a bash shell that runs in the
Windows environment.  

Most interactive commands are the same regardless of which shell you use, but the programming
languages for each shell are similar but definitely not the same.


## Which shell am I running?

When you launch a terminal window on Linux or MacOS, the system starts a shell program in
that window and you interact with that shell.  On MacOS, the default shell is `zsh`. On most
Linux installations, it is `bash`.  

To see what's happening on your computer, run the following command in a terminal window. Here,
and later, the initial '$' stands for the prompt you receive from the shell. Yours may be fancier.
We'll see later how to customize it.

```{bash}
$ echo $0
```

(Note: for a whole range of technical reasons this isn't 100% guaranteed to work but it is almost certainly correct!)

## Navigation

Your shell process always has a notion of "current directory." This is the folder/directory
that will be accessed by default when you run commands.  

When you start a shell, the current directory is your home directory.

Files and directories are referred to by paths that (in UNIX derived OS's) always use the '/' character.

**Two important conventions**

1. The current working directory is abbreviated as '.'
2. The *parent* of the current working directory is abbreviated as '..'

## Key Navigation Commands

The key commands for navigation through the file system are:

1. `pwd` prints the current working directory
2. `ls` lists the files in the current directory
3. `cd` changes the working directory
4. `mkdir` creates a new directory
5. `rmdir` deletes a directory, assuming it is empty.

Note: The '#' symbol means to treat everything following as a comment, not to be executed.

```{bash}
$ pwd
/home/jeremy9959
```

```{bash}
$ ls
data/  model.py  notes/
```

```{bash}
$ cd data # change working directory to data
$ pwd # check our working directory
/home/jeremy9959/data
$ ls # list files
test.csv  training.csv
$ cd .. # change to parent directory
$ pwd # confirm our location
/home/jeremy9959
```

## Options

Unix commands typically take (many) options.  The general structure of these options are either 
`-` followed by a letter, or `--word`. Sometimes you specify the option as `--word=value`.

```{bash}
$ (command) -a -b -c --name --option=whatever
```

You can usually run commands together like this:

```{bash}
$ (command) -abc
```

The `ls` command has many options and variations.  These vary from system to system. 

```{bash}
$ ls --help  # sometimes this works, but not always
$ man ls # this opens a manual page for the ls command which may tell you more than you want to know
```

Some important special cases that (almost always) work.

```{bash}
$ ls -l # long form listing
drwxrwxr-x - jet08013 11 Oct 09:21 data  # permissions/size/owner/group/modification date
.rw-rw-r-- 0 jet08013 11 Oct 09:20 model.py
drwxrwxr-x - jet08013 11 Oct 09:21 notes
```

```{bash}
$ ls -a # show  "hidden files" (names start with .)
.settings  data  model.py  notes
```

```{bash}
$ ls -F # 
data/ model.py notes/
```

```{bash}
$ ls data  # lists the contents of the directory
test.csv training.csv
$ ls -F -d data  # list the directory name
data/
```

You can also use wildcards.

```{bash}
$ ls *.py
model.py
$ ls -Fd d* # what happens if you just do ls -F?
data/
```
## Making and removing directories

You can always create a directory, but the system won't let you remote directories that aren't empty.

```{bash}
$ ls 
data  model.py  notes
$ mkdir report
$ ls -F
data/  model.py  notes/  report/
$ cd report
$ pwd
/home/jeremy9959/report
$ ls 
(nothing)
$ cd ..
$ pwd
/home/jeremy9959
$ rmdir report
$ ls -F
data/ model.py notes/
$ rmdir data
rmdir: failed to remote `data`: Directory not empty
$ ls data
test.csv  training.csv
```

## Working with files

Key commands for working with files.

- `nano` is a tiny text editor that works from the command line and is very easy to use. Other options
are `vi` and `emacs`.  `vscode` has options allowing you to work remotely as well.
- `cp` copy a file
- `mv` rename/move a file or directory
- `cat` type a file onto the terminal (or more generally combine files)
- `more` and `less` list files page by page
- `head` and `tail` look at first and last lines of a file
- `rm` remove/delete a file.

```{bash}
$ cd data
$ cp test.csv test_2.csv # make a new copy called test_2.csv
$ ls
test.csv test_2.csv training.csv
$ mv test_2.csv new_test.csv # rename test_2.csv to new_test.csv
$ ls
new_test.csv test.csv training.csv
$ cat test.csv
(... bunch of stuff)
$ head test.csv
(first ten lines)
$ tail test.csv
(last ten lines)
$ head -5 test.csv # first 5 lines
(first 5 lines)
$ tail -5 test.csv # last 5 lines
(last 5 lines)
$ ls 
new_test.csv test.csv training.csv
$ rm new_test.csv
rm: remove regular file 'new_test.csv'? y # you may not see this
$ ls
test.csv training.csv
```

Some variations that are useful to know about.

1. You can copy a bunch of files to a directory if the target of the copy is a directory.
You can use wildcards if you want.
```{bash}
$ cp file1 file2 file3 ... filen directory 
$ cp *.csv directory # copy all .csv files into the specified directory
```

2. The `mv` command will work on directories to rename them.
```{bash}
$ ls -F
data/ model.py notes/
$ mv data old_data
$ ls -F
model.py old_data/ notes/
```

3.  The `cp` command doesn't work on directories unless you use the `-r` or `--recursive` flag,
in which case it copies the entire directory tree.

4. You should assume that these operations are *irrevocable* and *destructive*. **There is no
trash can in UNIX** So for example
if you rename file1 ontop of another file2 , you delete the existing file2.  You can prevent this (and get warnings) with the `-i` flag.

```{bash}
$ rm -i model.py
rm: remove regular file `model.py`? n # cancel the operation
$  cp model.py model2.py 
$  mv model.py model2.py # this will overwrite model2.py 
$  ls -failed
data/ model2.py notes/
```

5. The -f flag means "force" and will override any warnings.  So `cp -f` will do a copy
over an existing file without a warning. In particular, `rm -f` will remove
a directory and its contents *even if the directory is nonempty*.  Use with extreme caution!

6. The shell wildcards are * (which matches anything) and ? which matches one character.

7. The `ls -R` command lists the contents of all subdirectories as well as the directory itself. 
The `tree` command (which isn't always available) gives you a nicer picture. 

```{bash}
$ tree 
.
├── data
│   ├── test.csv
│   └── training.csv
├── model.py
└── notes
    ├── algorithm_notes.txt
    └── to_do.txt
```

## Exercise

You receive the following note from your boss together with [this attachment](joe.zip).

```{md}
Hi, one of our analysts just quit and he sent me the attached zip file of his work so far
on one of our projects.  Can you get it organized?
```

Unzip the attachment.  Using the command line, organize the data into appropriate directories
and standardize the file names in a reasonable way.
